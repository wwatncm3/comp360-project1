import java.io.*;
import java.util.*;

public class RecursiveDescentParser {
    private List<Token> tokens;
    private int currentTokenIndex;

    public RecursiveDescentParser(List<Token> tokens) {
        this.tokens = tokens;
        this.currentTokenIndex = 0;
    }

    private Token peek() {
        return currentTokenIndex < tokens.size() ? tokens.get(currentTokenIndex) : null;
    }

    // Just checks if the next token matches the expected string and moves on
    private boolean match(String expected) {
        if (peek() != null && peek().getLexeme().equals(expected)) {
            currentTokenIndex++;
            return true;
        }
        return false;
    }
    
    // Helper to match any identifier based on token type (so weâ€™re not stuck on hardcoded names)
    private boolean matchIdentifier() {
        if (peek() != null && peek().getType() == TokenType.IDENTIFIER) {
            currentTokenIndex++;
            return true;
        }
        return false;
    }
    
    // Parses an expression (an identifier with optional chained * or / operations)
    private boolean parseExpression() {
        if (!matchIdentifier()) return false;
        while (peek() != null && (peek().getLexeme().equals("*") || peek().getLexeme().equals("/"))) {
            if (!(match("*") || match("/"))) return false;
            if (!matchIdentifier()) return false;
        }
        return true;
    }

    public void parseProgram() {
        if (!match("float")) {
            System.out.println("Syntax Error: Expected 'float' at the beginning.");
            return;
        }
        if (!match("sample1") && !match("mul")) {
            System.out.println("Syntax Error: Expected function identifier.");
            return;
        }
        if (!match("(")) {
            System.out.println("Syntax Error: Expected '('.");
            return;
        }
        if (!parseParameters()) {
            System.out.println("Syntax Error in function parameters.");
            return;
        }
        if (!match("{")) {
            System.out.println("Syntax Error: Expected '{'.");
            return;
        }
        if (!parseDeclarations()) {
            System.out.println("Syntax Error in variable declarations.");
            return;
        }
        if (!parseStatements()) {
            System.out.println("Syntax Error in statements.");
            return;
        }
        if (!parseLoop()) {
            System.out.println("Syntax Error in while loop.");
            return;
        }
        if (!match("}")) {
            System.out.println("Syntax Error: Expected '}' at end of function.");
            return;
        }
        System.out.println("The Source Code is generated by the BNF grammar.");
    }

    // Allow space-separated parameters and one or two parameters.
    private boolean parseParameters() {
        if (peek() != null && peek().getLexeme().equals("float")) {
            if (!match("float")) return false;
            if (!matchIdentifier()) return false;
            // If there's another parameter, check for it
            if (peek() != null && peek().getLexeme().equals("float")) {
                if (!match("float")) return false;
                if (!matchIdentifier()) return false;
            }
        }
        return match(")");
    }

    private boolean parseDeclarations() {
        while (match("float")) {
            
            if (!matchIdentifier()) {
                return false;
            }
            if (!match(";")) {
                return false;
            }
        }
        return true;
    }

    // Handles multiple operators by using parseExpression for the RHS
    private boolean parseStatements() {
        // Process statements as long as the next token is an identifier
        while (peek() != null && peek().getType() == TokenType.IDENTIFIER) {
            // Grab the LHS identifier.
            if (!matchIdentifier()) return false;
            if (!match("=")) return false;
            if (!parseExpression()) return false;
            if (!match(";")) return false;
        }
        return true;
    }

    // Just parses the while header with a condition expression.
    private boolean parseLoop() {
        if (match("while")) {
            if (!match("(")) return false;
            // Loop condition
            if (!matchIdentifier()) return false;
            if (!match(">=")) return false;
            if (!parseExpression()) return false;
            if (!match(")")) return false;
            return true;
        }
        return false;
    }

    public static void processFile(String filename) {
        try {
            BufferedReader reader = new BufferedReader(new FileReader(filename));
            StringBuilder sourceCode = new StringBuilder();
            String line;
            while ((line = reader.readLine()) != null) {
                sourceCode.append(line).append("\n");
            }
            reader.close();

            LexicalAnalyzer analyzer = new LexicalAnalyzer(sourceCode.toString());
            List<Token> tokens = analyzer.analyze();

            System.out.println("Processing file: " + filename);
            RecursiveDescentParser parser = new RecursiveDescentParser(tokens);
            parser.parseProgram();
        } catch (IOException e) {
            System.err.println("Error reading file: " + filename + " - " + e.getMessage());
        }
    }

    public static void main(String[] args) {
        processFile("sourcecode1.txt");
        processFile("sourcecode2.txt");
    }
}
