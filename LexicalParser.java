import java.io.*;
import java.util.*;

public class RecursiveDescentParser {
    private List<Token> tokens;
    private int currentTokenIndex;

    public RecursiveDescentParser(List<Token> tokens) {
        this.tokens = tokens;
        this.currentTokenIndex = 0;
    }

    private Token peek() {
        return currentTokenIndex < tokens.size() ? tokens.get(currentTokenIndex) : null;
    }

    private boolean match(String expected) {
        if (peek() != null && peek().getLexeme().equals(expected)) {
            currentTokenIndex++;
            return true;
        }
        return false;
    }

    public void parseProgram() {
        if (!match("float")) {
            System.out.println("Syntax Error: Expected 'float' at the beginning.");
            return;
        }
        if (!match("sample1") && !match("mul")) {
            System.out.println("Syntax Error: Expected function identifier.");
            return;
        }
        if (!match("(")) {
            System.out.println("Syntax Error: Expected '('.");
            return;
        }
        if (!parseParameters()) {
            System.out.println("Syntax Error in function parameters.");
            return;
        }
        if (!match("{")) {
            System.out.println("Syntax Error: Expected '{'.");
            return;
        }
        if (!parseDeclarations()) {
            System.out.println("Syntax Error in variable declarations.");
            return;
        }
        if (!parseStatements()) {
            System.out.println("Syntax Error in statements.");
            return;
        }
        if (!parseLoop()) {
            System.out.println("Syntax Error in while loop.");
            return;
        }
        if (!match("}")) {
            System.out.println("Syntax Error: Expected '}' at end of function.");
            return;
        }
        System.out.println("The Source Code is generated by the BNF grammar.");
    }

    private boolean parseParameters() {
        if (match("float")) {
            if (!match("data1") && !match("data") && !match("num") && !match("diff")) {
                return false;
            }
            if (match(",")) {
                return match("float") && match("number");
            }
        }
        return match(")");
    }

    private boolean parseDeclarations() {
        while (match("float")) {
            if (!match("data") && !match("num") && !match("diff") && !match("data1") && !match("number")) {
                return false;
            }
            if (!match(";")) {
                return false;
            }
        }
        return true;
    }

    private boolean parseStatements() {
        while (match("data") || match("data1") || match("n")) {
            if (!match("=")) return false;
            if (!match("data") && !match("data1") && !match("num") && !match("diff") && !match("number")) return false;
            if (match("*") || match("/")) {
                if (!match("num") && !match("diff") && !match("number")) return false;
            }
            if (!match(";")) return false;
        }
        return true;
    }

    private boolean parseLoop() {
        if (match("while")) {
            if (!match("(")) return false;
            if (!match("n") && !match("data")) return false;
            if (!match(">=")) return false;
            if (!match("10") && !match("const")) return false;
            if (!match(")")) return false;
            return parseStatements();
        }
        return false;
    }

    public static void main(String[] args) {
        try {
            BufferedReader reader = new BufferedReader(new FileReader("sourcecode.txt"));
            StringBuilder sourceCode = new StringBuilder();
            String line;
            while ((line = reader.readLine()) != null) {
                sourceCode.append(line).append("\n");
            }
            reader.close();

            LexicalAnalyzer analyzer = new LexicalAnalyzer(sourceCode.toString());
            List<Token> tokens = analyzer.analyze();

            RecursiveDescentParser parser = new RecursiveDescentParser(tokens);
            parser.parseProgram();
        } catch (IOException e) {
            System.err.println("Error reading file: " + e.getMessage());
        }
    }
}
