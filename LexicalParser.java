import java.io.*;
import java.util.*;

class Token {
    String type;
    String value;
    
    Token(String type, String value) {
        this.type = type;
        this.value = value;
    }
}

public class LexicalParser {
    static List<Token> tokens = new ArrayList<>();

    public static void lexicalAnalyzer(String sourceCode) {
        int position = 0;
        while (position < sourceCode.length()) {
            char currentChar = sourceCode.charAt(position);
            if (Character.isWhitespace(currentChar)) {
                position++;
                continue;
            }
            if (Character.isLetter(currentChar)) {
                StringBuilder word = new StringBuilder();
                while (position < sourceCode.length() && Character.isLetterOrDigit(sourceCode.charAt(position))) {
                    word.append(sourceCode.charAt(position++));
                }
                String wordStr = word.toString();
                if (wordStr.equals("float") || wordStr.equals("while")) {
                    tokens.add(new Token("KEYWORD", wordStr));
                } else {
                    tokens.add(new Token("IDENTIFIER", wordStr));
                }
                continue;
            }
            if (Character.isDigit(currentChar)) {
                StringBuilder number = new StringBuilder();
                while (position < sourceCode.length() && Character.isDigit(sourceCode.charAt(position))) {
                    number.append(sourceCode.charAt(position++));
                }
                tokens.add(new Token("NUMBER", number.toString()));
                continue;
            }
            String singleChar = String.valueOf(currentChar);
            if (singleChar.matches("[=*>]") || singleChar.equals("/")) {
                tokens.add(new Token("OPERATOR", singleChar));
                position++;
                continue;
            }
            if (singleChar.matches("[(){};]") ) {
                tokens.add(new Token("DELIMITER", singleChar));
                position++;
                continue;
            }
            position++; 
        }
    }

    public static boolean match(String expected) {
        if (!tokens.isEmpty() && tokens.get(0).value.equals(expected)) {
            tokens.remove(0);
            return true;
        }
        return false;
    }

    public static void parseProgram() {
        if (!match("float")) {
            System.out.println("Syntax Error: Expected 'float' at the beginning.");
            return;
        }
        if (!match("mul")) {
            System.out.println("Syntax Error: Expected function identifier.");
            return;
        }
        if (!match("(")) {
            System.out.println("Syntax Error: Expected '('.");
            return;
        }
        if (!match("float") || !match("data1") || !match(",") || !match("float") || !match("number") || !match(")") || !match("{")) {
            System.out.println("Syntax Error in function parameters or start.");
            return;
        }
        if (!match("data1") || !match("=") || !match("data1") || !match("*") || !match("number") || !match(";")) {
            System.out.println("Syntax Error in assignment statement.");
            return;
        }
        if (!match("while") || !match("(") || !match("data") || !match(">") || !match("const") || !match(")") || !match("}")) {
            System.out.println("Syntax Error in while loop.");
            return;
        }
        System.out.println("The Source Code is generated by the BNF grammar.");
    }

    public static void main(String[] args) {
        try {
            BufferedReader reader = new BufferedReader(new FileReader("sourcecode2.txt"));
            StringBuilder sourceCode = new StringBuilder();
            String line;
            while ((line = reader.readLine()) != null) {
                sourceCode.append(line).append("\n");
            }
            reader.close();
            lexicalAnalyzer(sourceCode.toString());
            parseProgram();
        } catch (IOException e) {
            System.err.println("Error reading file: " + e.getMessage());
        }
    }
}
